/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_WAVE_FROM_TOOLS__
#define __RUST_WAVE_FROM_TOOLS__

#ifdef __cplusplus
extern "C" {
#endif

/** \brief
 *  Returns f64;
 */
double get_f64 (
    double n,
    double m);

/** \brief
 *  Returns String;
 */
char * get_string (
    double n,
    double m);

/** \brief
 *  free String;
 */
void drop_string (
    char * string);


#include <stddef.h>
#include <stdint.h>

/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef enum CanvasStartPostion
#else
typedef uint8_t CanvasStartPostion_t; enum
#endif
{
    /** . */
    CANVAS_START_POSTION_LEFT_TOP = 1,
    /** . */
    CANVAS_START_POSTION_LEFT_BOTTOM = 2,
    /** . */
    CANVAS_START_POSTION_RIGHT_TOP = 3,
    /** . */
    CANVAS_START_POSTION_RIGHT_BOTTOM = 4,
}
#ifdef DOXYGEN
CanvasStartPostion_t
#endif
;

/** \brief
 *  A `struct` usable from both Rust and C
 */
typedef struct TestConfig {

    double gain;

    double speed;

    double cell_mg;

    double canvas_width;

    double canvas_height;

    CanvasStartPostion_t canvas_position;

} TestConfig_t;


#include <stdbool.h>

/** \brief
 *  Like [`slice_ref`] and [`slice_mut`], but with any lifetime attached
 *  whatsoever.
 * 
 *  It is only intended to be used as the parameter of a **callback** that
 *  locally borrows it, due to limitations of the [`ReprC`][
 *  `trait@crate::layout::ReprC`] design _w.r.t._ higher-rank trait bounds.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_raw_double {

    double * ptr;

    size_t len;

} slice_raw_double_t;

typedef struct TestStruct {

    double gain;

    double speed;

    char const * name;

    bool is_show;

    slice_raw_double_t list;

} TestStruct_t;

/** \brief
 *  Like [`slice_ref`] and [`slice_mut`], but with any lifetime attached
 *  whatsoever.
 * 
 *  It is only intended to be used as the parameter of a **callback** that
 *  locally borrows it, due to limitations of the [`ReprC`][
 *  `trait@crate::layout::ReprC`] design _w.r.t._ higher-rank trait bounds.
 * 
 *  # C layout (for some given type T)
 * 
 *  ```c
 *  typedef struct {
 *      // Cannot be NULL
 *      T * ptr;
 *      size_t len;
 *  } slice_T;
 *  ```
 * 
 *  # Nullable pointer?
 * 
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_raw_TestStruct {

    TestStruct_t * ptr;

    size_t len;

} slice_raw_TestStruct_t;

typedef struct TestInfo {

    TestConfig_t config;

    slice_raw_TestStruct_t test_struct;

} TestInfo_t;

/** \brief
 *  handle `struct` parameters
 */
void process_test_info (
    TestInfo_t test_info);

typedef struct ReturnStructv2 {

    double num;

    char * desc;

    bool is_show;

} ReturnStructv2_t;

/** \brief
 *  Returns the Struct -> ReturnStructv2
 */
ReturnStructv2_t get_test_struct (void);

typedef struct ReturnStruct {

    double num;

    char * desc;

} ReturnStruct_t;

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_ReturnStruct {

    ReturnStruct_t * ptr;

    size_t len;

    size_t cap;

} Vec_ReturnStruct_t;

/** \brief
 *  handle array parameter
 */
Vec_ReturnStruct_t test_array (
    slice_raw_TestStruct_t array);

void rust_free_return_struct (
    Vec_ReturnStruct_t array);


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __RUST_WAVE_FROM_TOOLS__ */
